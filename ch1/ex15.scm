;; Exercise 1.15
;; With the recursive definition of `sine` as shown below, 
(define default-dir "$HOME/var/sicp/")
(load "util/close.scm")

(define (sine angle)
  (define (cube x) (* x x x))
  (define (p x) (- (* 3 x) (* 4 (cube x))))
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

(assert (close? (sine 12.15) -0.39980345741334))

;; ... how many times is the procedure `p` called?
;; This question can be rephrased as "How many times must `12.15` be divided
;;   by `3` in order to get a number `< 0.1`?" In arithmetic notation, this
;;   is the same as "What is the smallest integer value of $n$?"

;; $$ \frac{12.15}{3^n} < 0.1 $$
;; $$ \implies 12.15 < 0.1 * 3^n $$
;; $$ \implies 121.5 < 3^n $$
;; $$ \implies log(121.5) < log(3^n) $$
;; $$ \implies log(121.5) < n * log(3) $$
;; $$ \implies \frac{log(121.5)}{log(3)} < n $$
;; $$ \implies log_3(121.5) < n $$
;; $$ \implies n > 4.36... $$
;; The smallest integer $n$ which holds is $ n = 5 $

;; The next part of the question asks how quickly the space and number of
;;  steps increaces with `a` for the process generated by `(sine a)`.

;; Since the result of a call to `sine` is either its argument, or the result
;;   of a call to `p`, and not a call to `sine`, the process is not rail
;;   recursive. This means that the space will grow linearly with the number
;;   of calls to `sine`, like so...

;; ```
;; (sine <large-number>)
;; (p (sine (/ <large-number> 3)))
;; (p (sine <large-number-by-3>))
;; (p (p (sine (/ <large-number-by-3> 3))))
;; (p (p (sine <large-number-by-9>)))
;; ...
;; (p (p ... (p (p <some-number>)...)))
;; (p (p ... (p (- (* 3 <some-number>) (* 4 (cube <some-number>))))))
;; ...
;; (p (p ... (p <some-other-number>)))
;; ```

;; So as `a` increaces, we expect the number of calls to `p` by the procedure
;;   to increace by `(/ a 3)`. Likewise, the required space will increase
;;   by the same factor. 
